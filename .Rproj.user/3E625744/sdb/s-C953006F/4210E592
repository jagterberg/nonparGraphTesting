{
    "collab_server" : "",
    "contents" : "#' Optimally transport according to wasserstein cost\n#' C_{ij} = d(QX_i, Y_j)^2\n#' Give two matrices of dimensions n x d and m x y respectively\n#' @param X an n x d matrix of points where each row is a point\n#' @param Y similar, except possibly a different number of points\n#' @param Q An orthogonal matrix\n#' @param lambda the parameter to penalize in sinkhorn divergence\n#' @param eps the tolerance\n#' @return P, the n x m matrix of assignments\n#' @export\noptimal_transport <- function(X,Y, Q= NULL,lambda = .1,eps = .01) {\n  if(is.null(Q)) {\n    d <- dim(X)[2]\n    Q <- diag(1,d,d)\n  }\n  X <- X%*%Q\n  C <- as.matrix(pdist::pdist(X,Y))^2\n\n  n <- dim(X)[1]\n  m <- dim(Y)[1]\n  r <- 1/n\n  c <- 1/m\n  P <- exp(-lambda * C)\n  u <- rep(0,n)\n  while (max(abs(u - rowSums(P))) > eps) {\n    u = rowSums(P)\n    P <- r*P / u\n    v <- colSums(P)\n    P <- c*t( t(P)/v)\n  }\n\n  return(P)\n\n}\n\n#' Function to find the optimal Q.  Classic Procrustes\n#' @param X the vectors X\n#' @param Y the vectors Y\n#' @param Pi the matrix of transports\n#' @export\n#' @return the procrustes solution\nprocrustes <- function(X,Y, Pi = NULL) {\n  if (is.null(Pi)) {\n    stop(\"need to run optimal transport first\")\n  }\n  vals <- svd(t(X)%*% Pi %*% Y)\n  toReturn <- vals$u %*% t(vals$v)\n  return(toReturn)\n\n}\n\n#' Function to iterate optimal transport based on sinkhorn divergence, for a fixed\n#' penalization parameter\n#' @param X the n x d matrix of vectors\n#' @param Y the m x d matrix of vectors\n#' @param Q optional, an initialization point\n#' @param lambda the penalization parameter\n#' @param eps tolerance for computing sinkhorn divergence\n#' @param numReps when to stop\n#' @return a list of the final Pi and Q\n#' @export\n#' @examples\n#' library(rstiefel)\n#' set.seed(2019)\n#' X <- matrix(rnorm(1000,1,.2),ncol= 4)\n#' Y <- rbind(X,X)\n#' W <- rustiefel(4,4)\n#' Y <- Y %*% W\n#' test <- iterative_optimal_transport(X,Y,numReps = 1000,lambda = .0001)\n#' norm(test$`Orthogonal Matrix` - W,\"2\")\n#' X <- matrix(rnorm(5000,.2,.02),ncol= 5)\n#' Y <- rbind(X,X)\n#' W <- rustiefel(5,5)\n#' Y <- Y %*% W\n#' Y <- matrix(rnorm(200,.7),ncol =5)\n#' test2 <- iterative_optimal_transport(X,Y,numReps = 1000,lambda = .0001)\n#' norm(test2$`Orthogonal Matrix` - W,\"2\")\niterative_optimal_transport <-function(X,Y, Q = NULL,lambda = .01,eps = .01,numReps =1000) {\n  if(is.null(Q)) {\n    d <- dim(X)[2]\n    Q <- diag(1,d,d)\n  }\n  Pi <- optimal_transport(X,Y,Q)\n  Q <- procrustes(X,Y,Pi)\n  c <- norm(X %*% Q - Pi%*% Y,\"F\")\n  i <- 1\n  while ( i < numReps) {\n    if( c > eps ) {\n\n      Pi <- optimal_transport(X,Y,Q)\n      Q <- procrustes(X,Y,Pi)\n      c <- norm(X %*% Q - Pi%*% Y)\n      i <- i+1\n    } else {\n      break\n    }\n\n  }\n  toReturn <- list(Pi,Q)\n  names(toReturn) <- c(\"Pi\", \"Orthogonal Matrix\")\n\n  return(toReturn)\n\n}\n\n#' Function to iterate over a decreasing sequence of lambdas, the penalization parameters.\n#' If lambda is big, the function is more concave, so we iterate, starting\n#' from Lambda = .5, and decreasing each time by alpha.\n#' This method takes longer, but is more likely to converge to the true solution,\n#' since we start from a more concave problem and iteratively solve it by setting\n#' lambda = alpha * lambda, for alpha \\in (0,1).\n#' @param X an n x d dataset of vectors\n#' @param Y an m x d dataset of vectors\n#' @param Q an initial guess\n#' @param lambda_init the initial value of lambda for penalization\n#' @param lambda_final For termination\n#' @param alpha the parameter for which lambda is multiplied by\n#' @param eps the tolerance for the optimal transport problem\n#' @param numReps the number of reps for each subiteration\n#' @return a list of the final orthogonal matrix and the assignment matrix\n#' @export\n#' @import pdist\n#' @import rstiefel\n#' @examples\n#' library(rstiefel)\n#'set.seed(2019)\n#' X <- matrix(rnorm(1000,1,.2),ncol= 4)\n#' Y <- rbind(X,X)\n#' W <- rustiefel(4,4)\n#' Y <- Y %*% W\n#' test <- solve_optimal_transport(X,Y)\n#' norm(test$`Orthogonal Matrix` - W,\"2\")\n#'\n#' X <- matrix(rnorm(1000,.2,.02),ncol= 5)\n#' Y <- rbind(X,X)\n#' W <- rustiefel(5,5)\n#' Y <- Y %*% W\n#' test2 <- solve_optimal_transport(X,Y)\n#' norm(test2$`Orthogonal Matrix` - W,\"2\")\nsolve_optimal_transport <- function(X,Y,\n                  Q = NULL,lambda_init = .5, lambda_final = .0001,alpha = .95,\n                  eps = .01,numReps =100) {\n\n  lambda <- lambda_init\n  if (is.null(Q)) {\n    d <- dim(X)[2]\n    Q <- diag(1,d,d)\n  }\n  while(lambda > lambda_final) {\n    Q <- iterative_optimal_transport(X,Y,Q,lambda = lambda,eps = eps,numReps = numReps)\n    Pi <- Q$Pi\n    Q <- Q$`Orthogonal Matrix`\n    lambda <- alpha*lambda\n  }\n\n  toReturn <- list(Pi,Q)\n  names(toReturn) <- c(\"Pi\", \"Orthogonal Matrix\")\n  return(toReturn)\n\n}\n\n\n\n\n\n",
    "created" : 1571779798108.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "678452797",
    "id" : "4210E592",
    "lastKnownWriteTime" : 1571781980,
    "last_content_update" : 1571781980025,
    "path" : "C:/Users/joshu/Dropbox/Documents/Research/grdpg_nonpar/optimal_transport/optimalTransportInvariance/R/optimal_transport.R",
    "project_path" : "R/optimal_transport.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}